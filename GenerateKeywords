#!/usr/bin/perl
# This work is licensed under a Creative Commons Attribution 3.0 Unported License (http://creativecommons.org/licenses/by/3.0/)
#
# Simple script that will generate two output files:
#   - include/Keywords - this is a  module to include which defines
#                    the keyword and options lists (so we know what to parse for)
#   - include/KeywordSearch - this is a binary search of the keyword id's and
#                    then calls the Action<Keyword>() routine
#
# There are clearly keywords that we do nothing with at execution time - which
# is why there is an 'Execute' bit - only the 'Execute' bit keywords are put into
# the binary search routines.                    

open(OUT, "> include/Keywords") || die "Failed to open include/Keywords: $!";

print OUT '
// Keyword module
//
// This module is generated by a perl script (GenerateKeywords) so do not
// edit this file, edit GenerateKeywords and run it to create include/Keywords
// (and include/KeywordSearch).
//
// This module is ALL about constants that define the keywords that we support.
// The way we work in this gadget is that ALL lines are parsed by keyword (or
// implied keyword) and then we execute based on keyword numbers and
// inner/outer parameters.

// Bit fields for the various optional parsing for the keywords
//  nice, simple table driven parsing :-)
';

@keynames = ('Integer', 'Float', 'SpecialString', 'String', 'RequiredNumber',
        'TwoFloats', 'LoopStarts', 'LoopEnds',
        'LastToken', 'AllowNegativeInt', 'Execute', 'MenuNumber', 'SkipParse');
        
# Same list order - but 0 = no param, 1 = inner param, 2 = outer param
@paramType = (1, 1, 1, 2, 1, 1, 0, 0, 0, 1, 0, 1);

$bit=1;
$innerBits = 0;
$outerBits = 0;
$j = 0;
foreach $i (@keynames)
{
    print OUT "#define key$i $bit\n";
    $values{$i} = $bit;
    
    $innerBits += $bit if ($paramType[$j] eq 1);
    $outerBits += $bit if ($paramType[$j] eq 2);
    
    $bit *= 2;
    $j++;
}

$keywords{'Alias'} = 'SpecialString,String';
$keywords{'Dance'} = 'String,Execute';
$keywords{'Delay'} = 'Float,RequiredNumber,Execute';
$keywords{'Dialog'} = 'String,Execute';
$keywords{'End'} = 'LoopEnds';
$keywords{'IM'} = 'String,Execute';
$keywords{'Give'} = 'String,Execute';
$keywords{'Group'} = 'SpecialString,String,LoopStarts';
$keywords{'Loop'} = 'LoopStarts,Integer,Default(2)';
$keywords{'Menu'} = 'Integer,String,MenuNumber,Default(menuNumber)';
$keywords{'MenuStyle'} = 'Integer,String,MenuNumber,Default(menuNumber)';
$keywords{'Message'} = 'Integer,AllowNegativeInt,RequiredNumber,String,Execute';
$keywords{'Mix'} = 'Integer,LoopStarts,Default(1)';
$keywords{'Name'} = 'String';
$keywords{'NextSequence'} = 'LastToken,String,Execute';
$keywords{'Owner_say'} = 'String,Execute';
$keywords{'Random'} = 'Integer,LoopStarts,Default(1)';
$keywords{'Rand'} = 'Float,RequiredNumber,TwoFloats,Execute';
$keywords{'Region_say'} = 'Integer,AllowNegativeInt,RequiredNumber,String,Execute';
$keywords{'Repeat'} = 'LastToken,Execute';
$keywords{'Say'} = 'Integer,AllowNegativeInt,RequiredNumber,String,Execute';
$keywords{'Setname'} = 'String,Execute';
$keywords{'Shout'} = 'Integer,AllowNegativeInt,RequiredNumber,String,Execute';
$keywords{'Stop'} = 'LastToken,Execute';
$keywords{'Style'} = 'String';
$keywords{'Whisper'} = 'Integer,AllowNegativeInt,RequiredNumber,String,Execute';
$keywords{'ZZZDefer'} = 'String,SkipParse,Execute';    # Used only internal to DanceControl - NOT a user defined keyword
# Keywords of another HUD that provides dance sequence support...
# These are the keywords we do NOT support at all
# $keywords{'Go'} =
# $keywords{'Ao_On'} =
# $keywords{'Ao_Off'} =
# $keywords{'Link'} =
# $keywords{'Map'} =
# $keywords{'Rez'} =
# $keywords{'Url'} =
# $keywords{'Target'} =
# $keywords{'Target_Last'} =
# $keywords{'Target_First'} =
# $keywords{'Hug'} =
# $keywords{'Email'} =
# $keywords{'Radio'} =
# $keywords{'No_Dance'} =

$total = 0;
foreach $i (sort keys %keywords)
{
    $total++;
}

print OUT '

#ifdef KEYWORD_TABLE

// List of possible keywords
list keywordTable = [
"|",     // Invalid keyword (takes up keyword id 0)
';

# Get all of OUR keywords first... (as number WILL matter)
$j=1;
$count = 1;
foreach $i (sort keys %keywords)
{
    @bits = split(',', $keywords{$i});
    $key = uc $i;
    if ($count < $total)
    {
        print OUT "\"$key\",     // $j : $keywords{$i}\n";
    }
    else
    {
        print OUT "\"$key\"     // $j : $keywords{$i}\n";
    }
    $j++;
    $count++;
}

print OUT '];     // End of list
';

print OUT '
// List of the keyword parameter types - see the bit fields above
//  (oh - please please please let expressions of constants turn into a constant in the future!)
list optionsTable = [
0,     // Invalid keyword (takes up keyword id 0), no options for invalid keyword
';

# Get all of OUR keywords first... (as number WILL matter)
$count = 1;
foreach $i (sort keys %keywords)
{
    @bits = split(',', $keywords{$i});
    $value = 0;
    foreach $j (@bits)
    {
        if (defined($values{$j}))
        {
            $value += $values{$j};
        }
    }
    if ($count < $total)
    {
        print OUT "$value,     // $i : $keywords{$i}\n";
    }
    else
    {
        print OUT "$value     // $i : $keywords{$i}\n";
    }
    $bitValue{$i} = $value;
    $count++;
}

print OUT '];     // End of list

#endif


// Define constant integers for the various keywords in the keywordTable
// Note: (I sure wish there was an enumeration type - but perl will do it)
';

$j = 1;
$k = 1;
foreach $i (sort keys %keywords)
{
    print OUT "#define keyword$i $j\n";
    $j++;
        
    # Ok - now we have a smaller set of commands that get executed - but we
    #  need to search for them and NOT just 1-N - so this is a sparce binary
    #  search - has hole in it... which will work as all of the numbers are
    #  in sequence - so long as we are careful to make sure to search by
    #  the appropriate number in the generated 'if' statements - the rest
    #  will simply fall out and work... hehe - this is all about optimizing
    #  for execution of ONLY the commands in the sequence that we need to
    #  use for running a dance sequence.
    if ($keywords{$i} =~ /Execute/)
    {
        $keyidMap{$k} = $j;
        $k++;
    }
}

print OUT '
// List of the default values - there are only a few and these are used in the
// Read module... but we need a list of them... zero when there is no default value.
#define defaultValuesList [0';
foreach $i (sort keys %keywords)
{
    print OUT ",";
        
    if ($keywords{$i} =~ /Default/)
    {
        my $defaultValue = $keywords{$i};
        $defaultValue =~ s/^.*Default\(//;
        $defaultValue =~ s/\).*$//;
        print OUT "$defaultValue";
    }
    else
    {
        print OUT "0";
    }
}
print OUT ']
';

close(OUT);

# Now we gather up the keywords that actually execute when we start a dance sequence...
$j = 1;
foreach $i (sort keys %keywords)
{
    if ($keywords{$i} =~ 'Execute')
    {
        $keyMap{$j} = $i;
        $j++;
    }
}


# Generate a binary search for the keyword ID and pass appropriate parameters to the sub-function
# This WILL bias a little bit to the first N items as they can be found in 5 or 6 compares and the rest in 6 compares exactly
# Can we optimize this so that DANCE and DELAY gets done in 5 compares? One extra compare doesn't matter much but it does
# make me wonder... if we look for a match at 3, and take the first one as the single instance - maybe...
open(OUT, "> include/KeywordSearch") || die "Failed to open include/KeywordSearch: $!";

$level = 0;

sub IndentLevel
{
    my($i);
    for ($i=0; $i < $level; ++$i)
    {
        print OUT "    ";
    }

}

$completed = -1;
$operationType = "Action";

# Print the appropriate call - either none, one or two parameters based on what the expected tokens provided :-)
sub printKeywordForSearch
{
    my($keyId) = @_;
    my($b) = $bitValue{$keyMap{$keyId}};
    
    IndentLevel();
    print OUT $operationType . "For$keyMap{$keyId}();    // Search level $level\n";
    IndentLevel();
    if ($keyMap{$keyId} eq "Delay")
    {
        print OUT "return 1;\n";
    }
    else
    {
        print OUT "return 0;\n";
    }    
}

sub GenerateSearch
{
    my($start,$end) = @_;
    my($midpoint) = $start + int(($end - $start) / 2);
    my($powerof2);
    
    # Print the header for the module..
    if ($level == 0)
    {
        print OUT '
// Binary search for keywords - execute the dance sequence as quickly as we can
';    
        print OUT "integer " . $operationType . "Keyword(integer k)
{
";
    }
    
    $level++;

    # Binary search generator
    #  Three possible conditions:
    #   1) We are at the same start/end value - so just indent and print the routine
    #   2) We have two values that are 1 apart - so compare for just the first and print/else print second
    #   3) We have two values that are farther apart
    #      3a) Let's normalize the value range to a power of 2 - this will make the binary search a bit more
    #          efficent (only on the very first call). We will use the power of 2 as the second half
    #      3b) Generate an IF for the midpoint, then recurse on the first half, else, then second half
    #      3c) If the range is 3 or less, then bias to a search of first 1, then 2
    
    # Case 1 - same value
    if ($start == $end)
    {
        printKeywordForSearch($start);
    }
    else
    {
        # Case 2 - only two values
        if ($start+1 == $end)
        {
            IndentLevel();
            print OUT "if (k == keyword" . $keyMap{$start} . ")\n";    
            IndentLevel();
            print OUT "{\n";
            $level++;
            printKeywordForSearch($start);
            $level--;
            IndentLevel();
            print OUT "}\n";
            IndentLevel();
            print OUT "else\n";    
            IndentLevel();
            print OUT "{\n";
            $level++;
            printKeywordForSearch($end);
            $level--;
            IndentLevel();
            print OUT "}\n";
        }
        else
        {
    
            # Case 3 - we have more than 2 values to search for - so make an IF of the midpoint
            if ($level == 1)
                {
                # Calculate the power of 2 that is the value just over the complete range
                #  then scale back one power of 2
                #
                # Now we can generate a nice binary search of the majority of the range and the
                # remaining part will be just fine... we'll just set the midpoint as the power of 2
                # and use the same generation code... :-) We'll bias the search so the tail end of
                # the search is nice and perfectly binary - the first part will have some keywords
                # that are a little faster - one integer comparison - as we add keywords this will
                # change which keywords get one less compare - hoping to bias it to [dance] and [delay]...
                for ($powerof2 = 1; $powerof2 < (($end-$start)+1); $powerof2 *= 2)
                    {
                    ;
                    }
                $powerof2 /= 2;
                $midpoint = $end - $powerof2;
                }
            
            if (3 == (($end-$start)+1))
            {
                $midpoint = $start;
                IndentLevel();
                print OUT "if (k == keyword" . $keyMap{$midpoint} . ")\n";
            }
            else
            {
                IndentLevel();
                print OUT "if (k <= keyword" . $keyMap{$midpoint} . ")\n";
            }
            IndentLevel();
            print OUT"{\n";
            GenerateSearch($start, $midpoint);
            IndentLevel();
            print OUT"}\n";
            IndentLevel();
            print OUT "else\n";
            IndentLevel();
            print OUT"{\n";
            GenerateSearch($midpoint+1, $end);
            IndentLevel();
            print OUT"}\n";
        }
    }
    $level--;
    
    # Print the trailer for the module..
    if ($level == 0)
    {
        print OUT '}
';
    }
    
}

$j--;
GenerateSearch(1, $j);

close(OUT);

