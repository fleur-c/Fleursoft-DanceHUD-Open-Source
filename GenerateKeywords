#!/usr/bin/perl
#
# Simple script that will generate two output files:
#   - include/Keywords - this is a  module to include which defines
#                    the keyword and options lists (so we know what to parse for)
#   - include/KeywordSearch - this is a binary search of the keyword id's and
#                    then calls the Action<Keyword>() routine
#
# There are clearly keywords that we do nothing with at execution time - which
# is why there is an 'Execute' bit - only the 'Execute' bit keywords are put into
# the binary search routines.                    

open(OUT, "> include/Keywords") || die "Failed to open include/Keywords: $!";

print OUT '
// Keyword module
//
// This module is generated by a perl script (GenerateKeywords) so do not
// edit this file, edit GenerateKeywords and run it to create include/Keywords
// (and include/KeywordSearch).
//
// This module is ALL about constants that define the keywords that we support.
// The way we work in this gadget is that ALL lines are parsed by keyword (or
// implied keyword) and then we execute based on keyword numbers and
// inner/outer parameters.

// Bit fields for the various optional parsing for the keywords
//  nice, simple table driven parsing :-)
';

@keynames = ('Integer', 'Float', 'SpecialString', 'String', 'RequiredNumber',
		'TwoFloats', 'LoopStarts', 'LoopEnds',
		'LastToken', 'AllowNegativeInt', 'Execute', 'MenuNumber', 'SkipParse');
		
# Same list order - but 0 = no param, 1 = inner param, 2 = outer param
@paramType = (1, 1, 1, 2, 1, 1, 0, 0, 0, 1, 0, 1);

$bit=1;
$innerBits = 0;
$outerBits = 0;
$j = 0;
foreach $i (@keynames)
{
	print OUT "#define key$i $bit\n";
	$values{$i} = $bit;
	
	$innerBits += $bit if ($paramType[$j] eq 1);
	$outerBits += $bit if ($paramType[$j] eq 2);
	
	$bit *= 2;
	$j++;
}

$keywords{'Alias'} = 'SpecialString,String';
$keywords{'Dance'} = 'String,Execute';
$keywords{'Delay'} = 'Float,RequiredNumber,Execute';
$keywords{'Dialog'} = 'String,Execute';
$keywords{'End'} = 'LoopEnds';
$keywords{'IM'} = 'String,Execute';
$keywords{'Give'} = 'String,Execute';
$keywords{'Group'} = 'SpecialString,String,LoopStarts';
$keywords{'Loop'} = 'LoopStarts,Integer';
$keywords{'Menu'} = 'Integer,String,MenuNumber';
$keywords{'MenuStyle'} = 'Integer,String,MenuNumber';
$keywords{'Message'} = 'Integer,String,AllowNegativeInt,Execute';
$keywords{'Mix'} = 'Integer,LoopStarts';
$keywords{'Name'} = 'String';
$keywords{'NextSequence'} = 'LastToken,String,Execute';
$keywords{'Owner_say'} = 'String,Execute';
$keywords{'Random'} = 'Integer,LoopStarts';
$keywords{'Rand'} = 'Float,RequiredNumber,TwoFloats,Execute';
$keywords{'Region_say'} = 'String,Integer,AllowNegativeInt,Execute';
$keywords{'Repeat'} = 'LastToken,Execute';
$keywords{'Say'} = 'Integer,String,AllowNegativeInt,Execute';
$keywords{'Setname'} = 'String,Execute';
$keywords{'Shout'} = 'String,Integer,AllowNegativeInt,Execute';
$keywords{'Stop'} = 'LastToken,Execute';
$keywords{'Style'} = 'String';
$keywords{'Whisper'} = 'String,Integer,AllowNegativeInt,Execute';
$keywords{'ZZZDefer'} = 'String,SkipParse,Execute';	# Used only internal to DanceControl - NOT a user defined keyword
# Keywords of another HUD that provides dance sequence support...
# These are the keywords we do NOT support at all
# $keywords{'Go'} =
# $keywords{'Ao_On'} =
# $keywords{'Ao_Off'} =
# $keywords{'Link'} =
# $keywords{'Map'} =
# $keywords{'Rez'} =
# $keywords{'Url'} =
# $keywords{'Target'} =
# $keywords{'Target_Last'} =
# $keywords{'Target_First'} =
# $keywords{'Hug'} =
# $keywords{'Email'} =
# $keywords{'Radio'} =
# $keywords{'No_Dance'} =

$total = 0;
foreach $i (sort keys %keywords)
{
	$total++;
}

print OUT '

#ifdef KEYWORD_TABLE

// List of possible keywords
list keywordTable = [
"|",     // Invalid keyword (takes up keyword id 0)
';

# Get all of OUR keywords first... (as number WILL matter)
$j=1;
$count = 1;
foreach $i (sort keys %keywords)
{
	@bits = split(',', $keywords{$i});
	$key = uc $i;
	if ($count < $total)
	{
		print OUT "\"$key\",     // $j : $keywords{$i}\n";
	}
	else
	{
		print OUT "\"$key\"     // $j : $keywords{$i}\n";
	}
	$j++;
	$count++;
}

print OUT '];     // End of list
';

print OUT '
// List of the keyword parameter types - see the bit fields above
//  (oh - please please please let expressions of constants turn into a constant in the future!)
list optionsTable = [
0,     // Invalid keyword (takes up keyword id 0), no options for invalid keyword
';

# Get all of OUR keywords first... (as number WILL matter)
$count = 1;
foreach $i (sort keys %keywords)
{
	@bits = split(',', $keywords{$i});
	$value = 0;
	foreach $j (@bits)
	{
		if (defined($values{$j}))
		{
			$value += $values{$j};
		}
		else
		{
			die "Failed to lookup value $j for keyword $i\n";
		}
	}
	if ($count < $total)
	{
		print OUT "$value,     // $i : $keywords{$i}\n";
	}
	else
	{
		print OUT "$value     // $i : $keywords{$i}\n";
	}
	$bitValue{$i} = $value;
	$count++;
}

print OUT '];     // End of list

#endif


// Define constant integers for the various keywords in the keywordTable
// Note: (I sure wish there was an enumeration type - but perl will do it)
';

$j = 1;
$k = 1;
foreach $i (sort keys %keywords)
{
	print OUT "#define keyword$i $j\n";
	$j++;
		
	# Ok - now we have a smaller set of commands that get executed - but we
	#  need to search for them and NOT just 1-N - so this is a sparce binary
	#  search - has hole in it... which will work as all of the numbers are
	#  in sequence - so long as we are careful to make sure to search by
	#  the appropriate number in the generated 'if' statements - the rest
	#  will simply fall out and work... hehe - this is all about optimizing
	#  for execution of ONLY the commands in the sequence that we need to
	#  use for running a dance sequence.
	if ($keywords{$i} =~ /Execute/)
	{
		$keyidMap{$k} = $j;
		$k++;
	}
}
close(OUT);

# Now we gather up the keywords that actually execute when we start a dance sequence...
$j = 1;
foreach $i (sort keys %keywords)
{
	if ($keywords{$i} =~ 'Execute')
	{
		$keyMap{$j} = $i;
		$j++;
	}
}


# Generate a binary search for the keyword ID and pass appropriate parameters to the sub-function
# This WILL bias a little bit to the first N items as they can be found in 5 or 6 compares and the rest in 6 compares exactly
# Can we optimize this so that DANCE and DELAY gets done in 5 compares? One extra compare doesn't matter much but it does
# make me wonder... if we look for a match at 3, and take the first one as the single instance - maybe...
open(OUT, "> include/KeywordSearch") || die "Failed to open include/KeywordSearch: $!";

$level = 0;

sub IndentLevel
{
	my($i);
	for ($i=0; $i < $level; ++$i)
	{
		print OUT "    ";
	}

}

$completed = -1;
$operationType = "Action";

# Print the appropriate call - either none, one or two parameters based on what the expected tokens provided :-)
sub printKeywordForSearch
{
	my($keyId) = @_;
	my($b) = $bitValue{$keyMap{$keyId}};
	
	IndentLevel();
	print OUT $operationType . "For$keyMap{$keyId}();	// Search level $level\n";
	IndentLevel();
	if ($keyMap{$keyId} eq "Delay")
	{
		print OUT "return 1;\n";
	}
	else
	{
		print OUT "return 0;\n";
	}	
}

sub GenerateSearch
{
	my($start,$end) = @_;
	my($midpoint) = $start + int(($end - $start) / 2);
	my($powerof2);
	
	# Print the header for the module..
	if ($level == 0)
	{
		print OUT '
// Binary search for keywords - execute the dance sequence as quickly as we can
';	
		print OUT "integer " . $operationType . "Keyword(integer k)
{
";
	}
	
	$level++;

	# Binary search generator
	#  Three possible conditions:
	#   1) We are at the same start/end value - so just indent and print the routine
	#   2) We have two values that are 1 apart - so compare for just the first and print/else print second
	#   3) We have two values that are farther apart
	#      3a) Let's normalize the value range to a power of 2 - this will make the binary search a bit more
	#          efficent (only on the very first call). We will use the power of 2 as the second half
	#      3b) Generate an IF for the midpoint, then recurse on the first half, else, then second half
	#      3c) If the range is 3 or less, then bias to a search of first 1, then 2
	
	# Case 1 - same value
	if ($start == $end)
	{
		printKeywordForSearch($start);
	}
	else
	{
		# Case 2 - only two values
		if ($start+1 == $end)
		{
			IndentLevel();
			print OUT "if (k == keyword" . $keyMap{$start} . ")\n";	
			IndentLevel();
			print OUT "{\n";
			$level++;
			printKeywordForSearch($start);
			$level--;
			IndentLevel();
			print OUT "}\n";
			IndentLevel();
			print OUT "else\n";	
			IndentLevel();
			print OUT "{\n";
			$level++;
			printKeywordForSearch($end);
			$level--;
			IndentLevel();
			print OUT "}\n";
		}
		else
		{
	
			# Case 3 - we have more than 2 values to search for - so make an IF of the midpoint
			if ($level == 1)
				{
				# Calculate the power of 2 that is the value just over the complete range
				#  then scale back one power of 2
				#
				# Now we can generate a nice binary search of the majority of the range and the
				# remaining part will be just fine... we'll just set the midpoint as the power of 2
				# and use the same generation code... :-) We'll bias the search so the tail end of
				# the search is nice and perfectly binary - the first part will have some keywords
				# that are a little faster - one integer comparison - as we add keywords this will
				# change which keywords get one less compare - hoping to bias it to [dance] and [delay]...
				for ($powerof2 = 1; $powerof2 < (($end-$start)+1); $powerof2 *= 2)
					{
					;
					}
				$powerof2 /= 2;
				$midpoint = $end - $powerof2;
				}
			
			if (3 == (($end-$start)+1))
			{
				$midpoint = $start;
				IndentLevel();
				print OUT "if (k == keyword" . $keyMap{$midpoint} . ")\n";
			}
			else
			{
				IndentLevel();
				print OUT "if (k <= keyword" . $keyMap{$midpoint} . ")\n";
			}
			IndentLevel();
			print OUT"{\n";
			GenerateSearch($start, $midpoint);
			IndentLevel();
			print OUT"}\n";
			IndentLevel();
			print OUT "else\n";
			IndentLevel();
			print OUT"{\n";
			GenerateSearch($midpoint+1, $end);
			IndentLevel();
			print OUT"}\n";
		}
	}
	$level--;
	
	# Print the trailer for the module..
	if ($level == 0)
	{
		print OUT '}
';
	}
	
}

$j--;
GenerateSearch(1, $j);

close(OUT);

