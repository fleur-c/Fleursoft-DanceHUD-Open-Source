// This started life as ZHAO-II-core with enhancements
//

#include "GlobalDefinitions"
#include "MenuList.h"
#include "Lists.h"


// ZHAO-II-core - Ziggy Puff, 07/07

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Main engine script - receives link messages from any interface script. Handles the core AO work
//
// Interface definition: The following link_message commands are handled by this script. All of 
// these are sent in the string field. All other fields are ignored
//
// ZHAO_RESET                          Reset script
// ZHAO_LOAD|<notecardName>            Load specified notecard
// ZHAO_NEXTSTAND                      Switch to next stand
// ZHAO_STANDTIME|<time>               Time between stands. Specified in seconds, expects an integer.
//                                     0 turns it off
// ZHAO_AOON                           AO On
// ZHAO_AOOFF                          AO Off
// ZHAO_SITON                          Sit On
// ZHAO_SITOFF                         Sit Off
// ZHAO_RANDOMSTANDS                   Stands cycle randomly
// ZHAO_SEQUENTIALSTANDS               Stands cycle sequentially
// ZHAO_SETTINGS                       Prints status
// ZHAO_SITS                           Select a sit
// ZHAO_GROUNDSITS                     Select a ground sit
// ZHAO_WALKS                          Select a walk
//
// ZHAO_SITANYWHERE_ON                 Sit Anywhere mod On 
// ZHAO_SITANYWHERE_OFF                Sit Anywhere mod Off 
//
// ZHAO_TYPE_ON                        Typing AO On 
// ZHAO_TYPE_OFF                       Typing AO Off 
//
// ZHAO_TYPEKILL_ON                    Typing Killer On 
// ZHAO_TYPEKILL_OFF                   Typing Killer Off 
//
// ZHAO_STANDON                          Sit On
// ZHAO_STANDOFF                         Sit Off
//
// So, to send a command to the ZHAO-II engine, send a linked message:
//
//   llMessageLinked(LINK_SET, 0, "ZHAO_AOON", NULL_KEY);
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////
// New notecard format
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
// Lines starting with a / are treated as comments and ignored. Blank lines are ignored. Valid lines 
// look like this:
//
// [ Walking ]SexyWalk1|SexyWalk2|SexyWalk3
//
// The token (in this case, [ Walking ]) identifies the animation to be overridden. The rest is a 
// list of animations, separated by the '|' (pipe) character. You can specify multiple animations 
// for Stands, Walks, Sits, and GroundSits. Multiple animations on any other line will be ignored. 
// You can have up as many animations each for Walks, Sits and GroundSits. There is no hard limit 
// on the number of stands, but adding too many stands will make the script run out of memory and 
// crash, so be careful. You can repeat tokens, so you can split the Stands up across multiple lines. 
// Use the [ Standing ] token in each line, and the script will add the animation lists together.
//
// Advanced: Each 'animation name' can be a comma-separated list of animations, which will be played 
// together. For example:
//
// [ Walking ]SexyWalk1UpperBody,SexyWalk1LowerBody|SexyWalk2|SexyWalk3
//
// Note the ',' between SexyWalk1UpperBody and SexyWalk1LowerBody - this tells ZHAO-II to treat these 
// as a single 'animation' and play them together. The '|' between this 'animation' and SexyWalk2 tells 
// ZHAO-II to treat SexyWalk2 and SexyWalk3 as separate walk animations. You can use this to layer 
// animations on top of each other.
//
// Do not add any spaces around animation names!!!
//
// The token can be one of the following:
//
// [ Standing ]
// [ Walking ]
// [ Sitting ]
// [ Sitting On Ground ]
// [ Crouching ]
// [ Crouch Walking ]
// [ Landing ]
// [ Standing Up ]
// [ Falling ]
// [ Flying Down ]
// [ Flying Up ]
// [ Flying ]
// [ Flying Slow ]
// [ Hovering ]
// [ Jumping ]
// [ Pre Jumping ]
// [ Running ]
// [ Turning Right ]
// [ Turning Left ]
// [ Floating ]
// [ Swimming Forward ]
// [ Swimming Up ]
// [ Swimming Down ]
// [ Typing ]
//
// [ Settings ]
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// Fleur Cooperstone - 2011-03-25
//			Merged the notecard loading code back into the core script (silly to seperate them at all)
//			Also dropped the listen completely - no need of it as we will NOT use dialogs for AO changes
//			And removed settings section too - no sense in them either - not standard on any other zhao... so gone.
//			Integrated messages with the Fleursoft DanceHUD - so that instead of dialogs we use the DanceHUD
//			for selections. Added cpp preprocessor handling of constants instead of variables (reduced variable
//			namespace being used). Removed seamless sits (won't work in opensim as id of animation doesn't make
//			any sense there). Dropped the idea of 'some' overrides could have multiple animations - they all can now.

// Marcus Gray, 2010-01-03
//          ADDED option to disable AO in Mouselook (interface, core)
//          ADDED possibility to set certain settings in a config notecard (adding  tag [ Settings ], editing loadcards only :P)

// Marcus Gray, 07/02/2009 (July 2nd)
//          hardened script against animation names containing ":" (":"-character is used for unlooped anims timing)
//          should now work with anything thas isn't ":" followed by only an integer (loadcards, minor core)

// interlude:
//          added this and that 0o, fixed some bugs i think
//          uhm
//          ...yeah           
//          at least some kindergarden level math errors x)


// Marcus Gray / Johann Ehrler, 09/28/2008:
//          Inserted some new parts for the stand-ON/OFF-toggle function.
//          Also terminated some typos.

// Johann Ehrler, 09/16/2008:
//          WARNING: This script was MONO-recompiled!

// Johann Ehrler, 04/19/2008:
//          Added support for custom animation timing.
//
// Johann Ehrler, 04/06/2008:
//          Some optimations are done...like cleaning up the code and merge it with newly
//          developed functions from a trunk of the core script.
//          Added the byte count to the free memory display for a much better geek factor. ;o)
//          The channel for the listener depends now on the owner UUID...not really necessary but funny.
//          Corrected some typos, redundant whitespaces and indentations.
//          Set Marcus change date to the right year. ;P

// Marcus Gray, 03/26/2008:
//          Included Seamless Sit mod by Moeka Kohime (core script).
//          Freed some memory DELETING THE DEFAULT UNOVERRIDABLE ANIMS!!!!!!!! (core script)
//          Added sit anywhere functionality to replace stands by groundsits (core script).
//          Therefore changed functionality of Sit-ON/OFF button to work as Sit Anywhere button (interface).

// Ziggy, 07/16/07 - Warning instead of error on 'no animation in inventory', that way SL's built-in
//                   anims can be used 
//
// Ziggy, 07/14/07 - 2 bug fixes. Listens aren't being reset on owner change, and a typo in the 
//                   ground sit animation code
//
// Ziggy, 06/07:
//          Reduce script count, since idle scripts take up scheduler time
//          Tokenize notecard reader, to simplify notecard setup
//          Remove scripted texture changes, to simplify customization by animation sellers

// Fennec Wind, January 18th, 2007:
//          Changed Walk/Sit/Ground Sit dialogs to show animation name (or partial name if too long) 
//          and only show buttons for non-blank entries.
//          Fixed minor bug in the state_entry, ground sits were not being initialized.
//

// Dzonatas Sol, 09/06: Fixed forward walk override (same as previous backward walk fix).

// Based on Francis Chung's Franimation Overrider v1.8

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.

// CONSTANTS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// List of all the animation states
#define animState [ "Sitting on Ground", "Sitting", "Striding", "Crouching", "CrouchWalking", \
                   "Soft Landing", "Standing Up", "Falling Down", "Hovering Down", "Hovering Up", \
                   "FlyingSlow", "Flying", "Hovering", "Jumping", "PreJumping", "Running", \
                   "Turning Right", "Turning Left", "Walking", "Landing", "Standing" ]

// Logic change - we now have a list of tokens. The 'overrides' list is the same length as this, 
// i.e. it has one entry per token, *not* one entry per animation. Multiple options for a token 
// are stored as | separated strings in a single list entry. This was done to save memory, and 
// allow a larger number of stands etc. All the xxxIndex variables now refer to the token index, 
// since that's how long 'overrides' is.

// List of internal tokens. This *must* be in the same sequence as the animState list. Note that
// we combine some tokens after the notecard is read (striding/walking, landing/soft landing), etc.
// The publicized tokens list only contains one entry for each pair, but we'll accept both, and
// combine them later
//
// We do NOT allow "Striding" or "Soft Landing" as a token
#define tokens  [ \
    "[ Sitting On Ground ]", \
    "[ Sitting ]", \
    "", \
    "[ Crouching ]", \
    "[ Crouch Walking ]", \
    "", \
    "[ Standing Up ]", \
    "[ Falling ]", \
    "[ Flying Down ]", \
    "[ Flying Up ]", \
    "[ Flying Slow ]", \
    "[ Flying ]", \
    "[ Hovering ]", \
    "[ Jumping ]", \
    "[ Pre Jumping ]", \
    "[ Running ]", \
    "[ Turning Right ]", \
    "[ Turning Left ]", \
    "[ Walking ]", \
    "[ Landing ]", \
    "[ Standing ]", \
    "[ Swimming Down ]", \
    "[ Swimming Up ]", \
    "[ Swimming Forward ]", \
    "[ Floating ]", \
    "[ Typing ]" ]

//
//      |       |       |
//      |       |       |
//      V       V       V
//
#define numOverrides 27
	// number of overrides == tokens

// Index of interesting animations
#define noAnimIndex -1
#define sitgroundIndex 0
#define sittingIndex 1
#define stridingIndex 2
#define softLandingIndex 5
#define standingupIndex 6
#define hoverdownIndex 8
#define hoverupIndex 9
#define flyingslowIndex 10
#define flyingIndex 11
#define hoverIndex 12
#define walkingIndex 18
#define landingIndex 19
#define standingIndex 20
#define swimdownIndex 21
#define swimupIndex 22
#define swimmingIndex 23
#define waterTreadIndex 24
#define typingIndex 25

// list of animations that have a different value when underwater
#define underwaterAnim [ hoverIndex, flyingIndex, flyingslowIndex, hoverupIndex, hoverdownIndex ]

// corresponding list of animations that we override the overrider with when underwater
#define underwaterOverride [ waterTreadIndex, swimmingIndex, swimmingIndex, swimupIndex, swimdownIndex]

// This is an ugly hack, because the standing up animation doesn't work quite right
// (SL is borked, this has been bug reported)
// If you play a pose overtop the standing up animation, your avatar tends to get
// stuck in place.
// This is a list of anims that we'll stop automatically
#define autoStop [ softLandingIndex, standingupIndex, landingIndex ]
// Amount of time we'll wait before autostopping the animation (set to 0 to turn off autostopping)
//  The duration is 1/10ths of seconds (so 15 really is 1.5 seconds)
#define autoStopTime 15

// How long before flipping stand animations
#define standTimeDefault 30

// How fast we should poll for changed anims (as fast as possible)
// In practice, you will not poll more than 8 times a second.
#define timerEventLength 0.25

// The minimum time between events.
// While timerEvents are scaled automatically by the server, control events are processed
// much more aggressively, and needs to be throttled by this script
#define minEventDelay 0.25

// GLOBALS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

integer typingStatus = FALSE;               // status of avatar typing

integer numTyping;                          // Number of typing anims
integer numStands;                          // Number of stands - needed for auto cycle
integer randomStands = FALSE;               // Whether stands cycle randomly
integer curStandIndex;                      // Current stand - needed for cycling
string curStandAnim = "";                   // Current Stand animation
string curSitAnim = "";                     // Current sit animation
string curWalkAnim = "";                    // Current walk animation
string curGsitAnim = "";                    // Current ground sit animation
string curTypingAnim = "";                  // Current typing animation

list overrides = [];                        // List of animations we override
key notecardLineKey = NULL_KEY;				// Key for loading a notecard
integer notecardIndex = 0;					// Which line number are we on?

string  lastAnim = "";                      // last Animation we ever played
string  lastAnimSet = "";                   // last set of animations we ever played
integer lastAnimIndex = 0;                  // index of the last animation we ever played
string  lastAnimState = "";                 // last thing llGetAnimation() returned

integer dialogStandTime = standTimeDefault;       // How long before flipping stand animations
integer standTime = standTimeDefault;       // How long before flipping stand animations

integer animOverrideOn = FALSE;             // Is the animation override on?
integer gotPermission  = FALSE;             // Do we have animation permissions?

integer listenHandle;                       // Listen handlers - only used for pop-up menu, then turned off

integer haveWalkingAnim = FALSE;            // Hack to get it so we face the right way when we walk backwards

integer sitOverride = TRUE;                 // Whether we're overriding sit or not
integer standOverride = TRUE;                 // Whether we're overriding sit or not
integer typingOverrideOn = TRUE;            // Whether we're overriding typing or not
integer typingKill = FALSE;                 // Whether we're killing the typing completely
integer mlAO = TRUE;                        // Whether AO is ON/OF in Mouselook
/// Sit Anywhere mod by Marcus Gray
/// just one var to overrider stands... let's see how this works out 0o
integer sitAnywhereOn = FALSE;

integer listenState = 0;                    // What pop-up menu we're handling now

integer loadInProgress = FALSE;             // Are we currently loading a notecard
string  notecardName = "";                  // The notecard we're currently reading

key Owner = NULL_KEY;

// String constants to save a few bytes
string EMPTY = "";
//
//
#define SEPARATOR "|"

string TRYAGAIN = "Please correct the notecard and try again.";
string S_SIT = "Sit override: ";
string S_SIT_AW = "Sit anywhere: ";
string S_TYPING = "Typing override: ";
string S_TKILL_ON = "Typing killer: On - This also removes custom typing animations!";
string S_TKILL_OFF = "Typing killer: Off";

// Globals for loading a notecard
integer counter;

//////////////////////////////////////////////////////////////////////////
startAnimationList( string _csvAnims ) {
    list anims = llCSV2List( _csvAnims );
    integer i;
    for( i=0; i<llGetListLength(anims); i++ )
    {
        llStartAnimation( llList2String(anims,i) );
    }
}

stopAnimationList( string _csvAnims ) {
    list anims = llCSV2List( _csvAnims );
    integer i;
    for( i=0; i<llGetListLength(anims); i++ )
    {
        llStopAnimation( llList2String(anims,i) );
    }
}

startNewAnimation( string _anim, integer _animIndex, string _state ) {
    if ( _anim != lastAnimSet ) {
        string newAnim;
        if ( lastAnim != EMPTY )
            stopAnimationList( lastAnim );
        if ( _anim != EMPTY ) {   // Time to play a new animation
             list newAnimSet = llParseStringKeepNulls( _anim, [SEPARATOR], [] );
             newAnim = llList2String( newAnimSet, (integer)llFloor(llFrand(llGetListLength(newAnimSet))) );

             startAnimationList( newAnim );

#if autoStopTime != 0
            if (llListFindList( autoStop, [_animIndex] ) != -1) {
                // This is an ugly hack, because the standing up animation doesn't work quite right
                // (SL is borked, this has been bug reported)
                // If you play a pose overtop the standing up animation, your avatar tends to get
                // stuck in place.
                if ( lastAnim != EMPTY ) {
                   stopAnimationList( lastAnim );
                   lastAnim = EMPTY;
                }
                llSleep( autoStopTime/10.0 );
                stopAnimationList( _anim );
            }
#endif
        }
        lastAnim = newAnim;
        lastAnimSet = _anim;
    }
    lastAnimIndex = _animIndex;
    lastAnimState = _state;
}

// Figure out what animation we should be playing right now
animOverride() {
    string  curAnimState = llGetAnimation( Owner );
    integer curAnimIndex;
    integer underwaterAnimIndex;
    // Convert the ones we don't handle
    if ( curAnimState == "Striding" ) {
        curAnimState = "Walking";
    } else if ( curAnimState == "Soft Landing" ) {
        curAnimState = "Landing";
    }

    // Remove the list check, since it only contains one element
    // Check if we need to work around any bugs in llGetAnimation
    // Hack, because, SL really likes to switch between crouch and crouchwalking for no reason
    if ( curAnimState == "CrouchWalking" ) {
      if ( llVecMag(llGetVel()) < .5 )
         curAnimState = "Crouching";
    }

    string _curAnimState = curAnimState;
    vector curPos = llGetPos();
    integer underwater = ( llWater(ZERO_VECTOR) > curPos.z );
    if(underwater)
    {
        if(curAnimState == "Flying")
            _curAnimState = "Swimming Forward";
        else if(curAnimState == "Hovering Up")
            _curAnimState = "Swimming Up";
        else if(curAnimState == "Hovering Down")
            _curAnimState = "Swimming Down";
        else if(curAnimState == "Hovering")
            _curAnimState = "Floating";
    }
    
    
    
    
    if ( _curAnimState == lastAnimState && _curAnimState != "Walking" ) {
        // This conditional not absolutely necessary (In fact it's better if it's not here)
        // But it's good for increasing performance.
        // One of the drawbacks of this performance hack is the underwater animations
        // If you fly up, it will keep playing the "swim up" animation even after you've
        // left the water.
        return;
    }

    curAnimIndex        = llListFindList( animState, [curAnimState] );
    underwaterAnimIndex = llListFindList( underwaterAnim, [curAnimIndex] );

    // For all the multi-anims, we know the animation name to play. Send
    // in the actual overrides index, since that's what this function 
    // expects, not the index into the multi-anim list
    if ( curAnimIndex == standingIndex )
    {
        // Sit Anywhere 
        if (sitAnywhereOn) { 
            startNewAnimation( curGsitAnim, sitgroundIndex, _curAnimState ); 
        }
        else 
        {
            if( standOverride )  // Sit Anywhere is OFF AND Stand AO is on ;)
                startNewAnimation( curStandAnim, standingIndex, _curAnimState );
            else
                 startNewAnimation( EMPTY, noAnimIndex, _curAnimState);
        }    
    }
    else if ( curAnimIndex == sittingIndex )
    {
        // Check if sit override is turned off
        if (( sitOverride == FALSE ) && ( curAnimState == "Sitting" )) 
            startNewAnimation( EMPTY, noAnimIndex, _curAnimState );
        else
            startNewAnimation( curSitAnim, sittingIndex, _curAnimState );
    }
    else if ( curAnimIndex == walkingIndex ) {
        startNewAnimation( curWalkAnim, walkingIndex, _curAnimState );
    }
    else if ( curAnimIndex == sitgroundIndex ) {
        startNewAnimation( curGsitAnim, sitgroundIndex, _curAnimState );
    }
    else {
        if ( underwaterAnimIndex != -1 ) {
            // Only call llGetPos if we care about underwater anims
            if (underwater ) {
                curAnimIndex = llList2Integer( underwaterOverride, underwaterAnimIndex );
            }
        }
        startNewAnimation( llList2String(overrides, curAnimIndex), curAnimIndex, _curAnimState );
    }
}

// Switch to the next stand anim
doNextStand(integer fromUI) {                           
    if ( numStands > 0) {
        if(!sitAnywhereOn && standOverride) { //no need to change stands if we're sitting anyways ;)
            if ( randomStands ) {
                curStandIndex = llFloor( llFrand(numStands) );
            } else {
                curStandIndex = (curStandIndex + 1) % numStands;
            }
    
            curStandAnim = findMultiAnim( standingIndex, curStandIndex );
            if ( lastAnimState == "Standing" )
                startNewAnimation( curStandAnim, standingIndex, lastAnimState );
    
            if ( fromUI == TRUE ) {
                string newAnimName = curStandAnim;
                OwnerSay( "Switching to stand '" + newAnimName + "'." );
            }
        }
    } else {
        if ( fromUI == TRUE ) {
            OwnerSay( "No stand animations configured." );
        }
    }

    llResetTime();
}

// Start or stop typing animation
typingOverride(integer isTyping) {
    if(isTyping) {  
        if( typingKill ) { // if we totally kill typing anims
            llStopAnimation("type");
//            typingStatus = FALSE;
        }
        else
        {
            integer curTypingIndex = 0;
            if(numTyping > 1) {
                curTypingIndex = llFloor( llFrand(numTyping) );
            }
            curTypingAnim = findMultiAnim( typingIndex, curTypingIndex );
            startAnimationList(curTypingAnim);
        }
    }
    else if( !typingKill )
    {  
        stopAnimationList(curTypingAnim);
    }
}

// Displays menu of animation choices
doMultiAnimMenu( integer _animIndex, string _animType, string _currentAnim )
{
    // Dialog enhancement - Fennec Wind
    // Fix - a no-mod anim with a long name will break this

    list anims = llParseString2List( llList2String(overrides, _animIndex), [SEPARATOR], [] );
    integer numAnims = llGetListLength( anims );

    if ( numAnims > Define_DefaultNumberLines ) {
        OwnerSay( "Too many animations, only the first "+(string)Define_DefaultNumberLines+" will be displayed.");
        numAnims = Define_DefaultNumberLines;
    }

    integer i;
    string animNames = EMPTY;
    for ( i=0; i<numAnims; i++ ) {
        animNames += llList2String( anims, i )+"|"+(string)Define_AOSELECTLINKID+"|"+(string)i;
        if (i != (numAnims-1))
        	animNames += "|||";
    }
    // If no animations were configured, say so and just display an "OK" button
    if ( animNames == EMPTY ) {
        llOwnerSay("No overrides have been configured.");
        return;
    }
    MessageSendMenuRange(Define_UILINKID, _animType, numAnims, 0, Define_FlagRangeConstrainedMenu, Define_AOSELECTLINKID, animNames);
}

// Returns an animation from the multiAnims
string findMultiAnim( integer _animIndex, integer _multiAnimIndex )
{
    list animsList = llParseString2List( llList2String(overrides, _animIndex), [SEPARATOR], [] );
    return llList2String( animsList, _multiAnimIndex );
}

// Returns true if we should override the current animation
integer checkAndOverride() {
    if ( animOverrideOn && gotPermission ) {
        animOverride();
        return TRUE;
    }
    return FALSE;
}

// Load all the animation names from a notecard
loadNoteCard() {

    if ( llGetInventoryKey(notecardName) == NULL_KEY ) {
        OwnerSay( "Notecard '" + notecardName + "' does not exist, or does not have full permissions." );
        notecardName = EMPTY;
        loadInProgress = FALSE;
        return;
    }
    else {
    
        loadInProgress = TRUE;

        overrides = [];
        integer i;
        for ( i=0; i<numOverrides; i++ )
            overrides += [EMPTY];

        curStandIndex = 0;
        curStandAnim = EMPTY;
        curSitAnim = EMPTY;
        curWalkAnim = EMPTY;
        curGsitAnim = EMPTY;
    
	    OwnerSay( "Loading AO notecard '" + notecardName + "'..." );
	    counter = 0;
	    notecardIndex = 0;
	    notecardLineKey = llGetNotecardLine( notecardName, notecardIndex );
    }
}

checkAnimInInventory( string _csvAnims )
{
    list anims = llCSV2List( _csvAnims );
    integer i;
    for( i=0; i<llGetListLength(anims); i++ )
    {
	    if ( llGetInventoryType( llList2String(anims,i) ) != INVENTORY_ANIMATION )
	        OwnerSay( "Warning: Couldn't find animation '" + llList2String(anims,i) + "' in inventory." );
    }
}

// Stop loading notecard
endNotecardLoad(integer success)
{
    if(success)
    {
        OwnerSay((string)counter + " animation entries found in AO notecard.");

        // Do we have a walking animation?
        if ( llList2String(overrides, walkingIndex) != EMPTY ) {
             haveWalkingAnim = TRUE;
        }
        // Reset stand, walk, sit and ground-sit anims to first entry
        curStandIndex = 0;
        numStands = llGetListLength( llParseString2List(llList2String(overrides, standingIndex), 
                                     [SEPARATOR], []) );
                                         
        numTyping = llGetListLength( llParseString2List(llList2String(overrides, typingIndex), 
                                     [SEPARATOR], []) );

        curStandAnim = findMultiAnim( standingIndex, 0 );
        curWalkAnim = findMultiAnim( walkingIndex, 0 );
        curSitAnim = findMultiAnim( sittingIndex, 0 );
        curGsitAnim = findMultiAnim( sitgroundIndex, 0 );

        // Clear out the currently playing anim so we play the new one on the next cycle
        startNewAnimation( EMPTY, noAnimIndex, lastAnimState );
        lastAnim = EMPTY;
        lastAnimSet = EMPTY;
        lastAnimIndex = noAnimIndex;
        lastAnimState = EMPTY;

        OwnerSay( "Finished reading AO notecard '" + notecardName + "'." );
        MessageMenuRememberAO(notecardName);
        }

    loadInProgress = FALSE;
    notecardName = EMPTY;

    // Restore the minimum event delay
    llMinEventDelay( minEventDelay );
}

// Initialize listeners, and reset some status variables
initialize() {
    Owner = llGetOwner();
    
    llSetTimerEvent( 0.0 );

    if ( animOverrideOn )
        llSetTimerEvent( timerEventLength );

    lastAnim = EMPTY;
    lastAnimSet = EMPTY;
    lastAnimIndex = noAnimIndex;
    lastAnimState = EMPTY;
    gotPermission = FALSE;
}

integer chatMessageOn = TRUE;

OwnerSay(string data)
{
    if(chatMessageOn)
        llOwnerSay(data);
}

// STATE
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

default {
    state_entry() {
        integer i;

        Owner = llGetOwner();

		if ( llGetAttached() )
            llRequestPermissions( llGetOwner(), PERMISSION_TRIGGER_ANIMATION|PERMISSION_TAKE_CONTROLS );
        // populate override list with blanks
        overrides = [];
        for ( i=0; i<numOverrides; i++ ) {
            overrides += [ EMPTY ];
        }
        randomStands = FALSE;
        initialize();

        llResetTime();
        
		// Clear the remove access pin so that scripts can NOT be overwritten normally...
		//  This is the LAST script to get updated via updates - so good to do here!
		llSetRemoteScriptAccessPin(0);        
    }

    on_rez( integer _code ) {
        initialize();
    }

    attach( key _k ) {
        if ( _k != NULL_KEY )
            llRequestPermissions( llGetOwner(), PERMISSION_TRIGGER_ANIMATION|PERMISSION_TAKE_CONTROLS );
    }

    run_time_permissions( integer _perm ) {
      if ( _perm != (PERMISSION_TRIGGER_ANIMATION|PERMISSION_TAKE_CONTROLS) )
         gotPermission = FALSE;
      else {
         llTakeControls( CONTROL_BACK|CONTROL_FWD, TRUE, TRUE );
         gotPermission = TRUE;
      }
    }

    link_message( integer _sender, integer _num, string _message, key _id) {
    
		// Optimize for dropping messages very quickly - so not a lot of lag during useless message handling
		//  think of this as an optimized get out of here quickly check.
		if (-1 == llListFindList([Define_AOLINKID, Define_AOSELECTLINKID, 0], [_num]))
		{
		        return; // Not our message - poof - go away quickly
		}

        // Coming from an interface script
        if ((_num == 0) && ( _message == "RESET" )) {
            
            if(gotPermission)
            {
                if ( lastAnim != EMPTY )
                    stopAnimationList( lastAnim );
                if ( curTypingAnim != EMPTY )
                stopAnimationList(curTypingAnim);
            }
            llResetScript();
           	return;	// Can't get here - but makes me feel better
        }
        
        // Filter out ALL messages except for our designated number
        if (Define_AOLINKID == _num)
        {
        if ( _message == "ZHAO_AOON" ) {
            // AO On
            llSetTimerEvent( timerEventLength );
            animOverrideOn = TRUE;
            checkAndOverride();
            return;
        
        }
        if ( _message == "ZHAO_AOOFF" ) {
            //AO OFF
            llSetTimerEvent( 0.0 );
            animOverrideOn = FALSE;
            startNewAnimation( EMPTY, noAnimIndex, lastAnimState );
            lastAnim = EMPTY;
            lastAnimSet = EMPTY;
            lastAnimIndex = noAnimIndex;
            lastAnimState = EMPTY;
            // There is NO release of permissions... the API is busted and the only way is to reset and we don't want to do that here... we'd forget the notecard...
            return;
        }
        if ( _message == "CHAT_ON" ) {
            chatMessageOn = TRUE;
            return;
        }
        if ( _message == "CHAT_OFF" ) {
            chatMessageOn = FALSE;
            return;
        }
        if ( _message == "ZHAO_STANDON" ) {
            // Turning on sit override
            standOverride = TRUE;
            OwnerSay( "Stand AO On" );
            if ( lastAnimState == "Standing" )
                startNewAnimation( curStandAnim, standingIndex, lastAnimState );
            return;
        }
        if ( _message == "ZHAO_STANDOFF" ) {
            // Turning off sit override
            standOverride = FALSE;
            OwnerSay( "Stand AO Off" );
            if ( lastAnimState == "Standing" )
                startNewAnimation( EMPTY, noAnimIndex, lastAnimState );
        	return;
        }
        if ( _message == "ZHAO_SITON" ) {
            // Turning on sit override
            sitOverride = TRUE;
            OwnerSay( S_SIT + "On" );
            if ( lastAnimState == "Sitting" )
                startNewAnimation( curSitAnim, sittingIndex, lastAnimState );
        	return;
        }
        if ( _message == "ZHAO_SITOFF" ) {
            // Turning off sit override
            sitOverride = FALSE;
            OwnerSay( S_SIT + "Off" );
            if ( lastAnimState == "Sitting" )
                startNewAnimation( EMPTY, noAnimIndex, lastAnimState );
			return;        
        }
        if ( _message == "ZHAO_SITANYWHERE_ON" ) {
            // Turning on sit anywhre mod
            sitAnywhereOn = TRUE;
            OwnerSay( S_SIT_AW + "On" );
            if ( lastAnimState == "Standing" )
                startNewAnimation( curGsitAnim, sitgroundIndex, lastAnimState );
        	return;
        }
        if ( _message == "ZHAO_SITANYWHERE_OFF" ) {
            // Turning off sit anywhere mod
            sitAnywhereOn = FALSE;
            OwnerSay( S_SIT_AW + "Off" );
            if ( lastAnimState == "Standing" )
                startNewAnimation( curStandAnim, standingIndex, lastAnimState );
			return;        
        }
        if ( _message == "ZHAO_TYPEAO_ON" ) {
            // Turning on typing override
            typingOverrideOn = TRUE;
            OwnerSay( S_TYPING + "On" );                    
            typingStatus = FALSE;
        	return;    
        }
        if ( _message == "ZHAO_TYPEAO_OFF" ) {
            // Turning off typing override
            typingOverrideOn = FALSE;
            OwnerSay( S_TYPING + "Off" );
            if ( typingStatus && !typingKill ) {
                stopAnimationList(curTypingAnim);
                typingStatus = FALSE;
            }
            return;   
        }
        if ( _message == "ZHAO_TYPEKILL_ON" ) {
            // Turning on Typing killer
            typingKill = TRUE;
            OwnerSay( S_TKILL_ON );        
            typingStatus = FALSE;
            return;
        }
        if ( _message == "ZHAO_TYPEKILL_OFF" ) {
            // Turning off Typing killer
            typingKill = FALSE;
            OwnerSay( S_TKILL_OFF );
            typingStatus = FALSE;
            return;
        }
        if ( _message == "ZHAO_RANDOMSTANDS" ) {
            // Cycling to next stand - sequential or random
            randomStands = TRUE;
            OwnerSay( "Stand cycling: Random" );
        	return;
        }
        if ( _message == "ZHAO_SEQUENTIALSTANDS" ) {
            // Cycling to next stand - sequential or random
            randomStands = FALSE;
            OwnerSay( "Stand cycling: Sequential" );
            return;
        }
        if ( _message == "ZHAO_SETTINGS" ) {
            // Print settings
            if ( sitOverride ) {
                OwnerSay( S_SIT + "On" );
            } else {
                OwnerSay( S_SIT + "Off" );
            }
            if ( sitAnywhereOn ) {
                OwnerSay( S_SIT_AW + "On" );
            } else {
                OwnerSay( S_SIT_AW + "Off" );
            }
            if ( typingOverrideOn ) {
                OwnerSay( S_TYPING + "On" );
            } else {
                OwnerSay( S_TYPING + "Off" );
            }
            if ( typingKill ) {
                OwnerSay( S_TKILL_ON );
            } else {
                OwnerSay( S_TKILL_OFF );
            }
            if ( randomStands ) {
                OwnerSay( "Stand cycling: Random" );
            } else {
                OwnerSay( "Stand cycling: Sequential" );
            }
            OwnerSay( "Stand cycle time: " + (string)dialogStandTime + " seconds" );
			return;
        }
        if ( _message == "ZHAO_NEXTSTAND" ) {
            // Cycling to next stand - sequential or random. This is from UI, so we
            // want feedback
            doNextStand( TRUE );
            return;
        
        }
        if ( llGetSubString(_message, 0, 14) == "ZHAO_STANDTIME|" ) {
            // Stand time change
            dialogStandTime = (integer)llGetSubString(_message, 15, -1);
            OwnerSay( "Stand cycle time: " + (string)dialogStandTime + " seconds" );
            return;
        
        }
        if ( llGetSubString(_message, 0, 9) == "ZHAO_LOAD|" ) {
            // Can't load while we're in the middle of a load
            if ( loadInProgress == TRUE ) {
                OwnerSay( "Cannot load new notecard, still reading notecard '" + notecardName + "'" );
                return;
            }
            // Notecard menu
            notecardName = llGetSubString(_message, 10, -1);
            loadNoteCard();
            return;

        }
        if ( _message == "ZHAO_SITS" ) {
            // Selecting new sit anim

            // Move these to a common function
            doMultiAnimMenu( sittingIndex, "Sitting", curSitAnim );

            listenState = 1;
            return;

        }
        if ( _message == "ZHAO_WALKS" ) {
            // Same thing for the walk

            // Move these to a common function
            doMultiAnimMenu( walkingIndex, "Walking", curWalkAnim );

            listenState = 2;
            return;

        }
        if ( _message == "ZHAO_GROUNDSITS" ) {
            // And the ground sit

            // Move these to a common function
            doMultiAnimMenu( sitgroundIndex, "Sitting On Ground", curGsitAnim );

            listenState = 3;
            return;
        } 
        
        }	// End if we received message on the correct number (filtered for lag reduction)
        
        // Handle the case of a list of animations from the pretty gui (instead of a dialog box)
        if (Define_AOSELECTLINKID == _num)
        {
        	// Constrained menus mean that the user can only choose what is on them - no scrolling and not outside the range...
        	list p = llParseString2List(_message, ["|"], []);

	        if ( listenState == 1 ) {
	            // Dialog enhancement - Fennec Wind
	            // Note that this is within one 'overrides' entry
	            curSitAnim = findMultiAnim( sittingIndex, llList2Integer(p,1) );
	            if ( lastAnimState == "Sitting" ) {
	                startNewAnimation( curSitAnim, sittingIndex, lastAnimState );
	            }
	           OwnerSay( "New sitting animation: " + curSitAnim );
	
	        } else if ( listenState == 2 ) {
	            // Dialog enhancement - Fennec Wind
	            // Note that this is within one 'overrides' entry
	            curWalkAnim = findMultiAnim( walkingIndex, llList2Integer(p,1) );
	            if ( lastAnimState == "Walking" ) {
	                startNewAnimation( curWalkAnim, walkingIndex, lastAnimState );
	            }
	            OwnerSay( "New walking animation: " + curWalkAnim );
	
	        } else if ( listenState == 3 ) {
	            // Dialog enhancement - Fennec Wind
	            // Note that this is within one 'overrides' entry
	            curGsitAnim = findMultiAnim( sitgroundIndex,llList2Integer(p,1) );
	            // Lowercase 'on' - that's the anim name in SL
	            if ( lastAnimState == "Sitting on Ground" || ( lastAnimState == "Standing" && sitAnywhereOn ) ) {
	                startNewAnimation( curGsitAnim, sitgroundIndex, lastAnimState );
	            }
	            OwnerSay( "New sitting on ground animation: " + curGsitAnim );
	        }
	        
	        MessageGoToMenu(Define_AOMENULINKID);		// Return back to the standard AO menu
        }
    }

    changed(integer _change) {
        if(_change & CHANGED_TELEPORT) {
            lastAnimSet = EMPTY;
            lastAnimState = EMPTY;
            checkAndOverride();
        }

        if (_change & CHANGED_OWNER)
            llResetScript();
    }

    collision_start( integer _num ) {
        checkAndOverride();
    }

    collision( integer _num ) {
    //   checkAndOverride();
    }

    collision_end( integer _num ) {
       checkAndOverride();
    }

    control( key _id, integer _level, integer _edge ) {
        if ( _edge ) {
            // SL tends to mix animations together on forward or backward walk. It could be because
            // of anim priorities. This helps stop the default walking anims, so it won't mix with
            // the desired anim. This also lets the avi turn around on a backwards walk for a more natural
            // look.
            // Reverse the order of the checks, since we'll often get the control key combination, but we
            // may be flying
            if (animOverrideOn && llGetAnimation(Owner) == "Walking" ) {
                if ( _level & _edge & ( CONTROL_BACK | CONTROL_FWD ) ) {
                    if ( haveWalkingAnim ) {
                        llStopAnimation( "walk" );
                        llStopAnimation( "female_walk" );
                    }
                }
            }

            checkAndOverride();
        }
    }

    timer() {
        // TYPING AO!!!!!!!!!!!
        if( ( numTyping > 0 && typingOverrideOn ) || typingKill ) {            
            integer typingTemp = llGetAgentInfo( Owner ) & AGENT_TYPING; // are we typing?
            if ( typingTemp != typingStatus ) { //status changed since last checked?
                typingOverride( typingTemp );
                typingStatus = typingTemp;//save the current status.
            }
        }
        if( checkAndOverride() ) {
            // Is it time to switch stand animations?
            // Stand cycling can be turned off
            if ( (standTime != 0) && ( llGetTime() > standTime ) ) {
                // Don't interrupt the typing animation with a stand change. 
                // Not from UI, no feedback
                if ( !typingStatus )
                    doNextStand( FALSE );
            }
        }
    }

    dataserver( key _query_id, string _data ) 
    {
        if ( _query_id != notecardLineKey )
        {
            return;		// If it's not our data - get out of here... this caused the load of another notecard to clear the AO settings I think...
        }
        if ( _data == EOF )
        {
            endNotecardLoad(TRUE);
            return;
        }
        if (( _data == EMPTY ) || ( llGetSubString(_data, 0, 0) == "#" ))
        {
            notecardLineKey = llGetNotecardLine( notecardName, ++notecardIndex );
            return;
        }

        integer i;
        integer found = FALSE;
        for ( i=0; (i<numOverrides) && !found; i++ )
        {
            string token = llList2String( tokens, i );          
            if (( token != EMPTY ) && ( llGetSubString( _data, 0, llStringLength(token) - 1 ) == token ))
            {
                found = TRUE;
                if ( _data != token )
                {                    
                    string animPart = llGetSubString( _data, llStringLength(token), -1 );
                    list anims2Add = llParseString2List( animPart, [SEPARATOR], [] );
                    integer j;
                    for ( j=0; j<llGetListLength(anims2Add); j++ )
                    {
						string newAnimName = llList2String(anims2Add,j);
                        checkAnimInInventory( newAnimName );
                        ++counter;
                    }
					string s =  llList2String(overrides, i);
					if (s != EMPTY)
					{
                    	list currentAnimsList = llParseString2List(s, [SEPARATOR], [] );
                    	currentAnimsList = (currentAnimsList=[]) + currentAnimsList + anims2Add;
                    	overrides = llListReplaceList( overrides, [llDumpList2String(currentAnimsList, SEPARATOR)], i, i );
                    }
                    else
                        overrides = llListReplaceList( overrides, [animPart], i, i );                       
                }
            }
        }
        if ( !found )
        {
            OwnerSay( "Could not recognize token on line " + (string)notecardIndex + ": " + _data + ". " + TRYAGAIN );
            endNotecardLoad(FALSE);
            return;
        }

        notecardLineKey = llGetNotecardLine( notecardName, ++notecardIndex );
        return;
    }
}
